本書の前章の通り、我々は時に制限つきの、単純化した形でアイデアを紹介することを覚えておいてほしい。Haskellは深みのある言語であり、与えられた話題の全ての局面を一度に提示することは恐らく圧倒的と証明する。我々はHaskellで堅固な基礎を築き、この最初の説明を発展していくだろう。

<h2>Your Haskell Environment</h2>
Haskellは多くの実装のある言語であり、そのうち二つが広く使われている。Hugsはインタプリタであり、第一に教育に使われている。実際的なアプリケーションにはGlasgow Haskell Compiler(GHC)がより一般的である。Hugsに比べてGHCは実務に適している:それはネイティブコードにコンパイルし、並列実行をサポートし、有用なパフォーマンス分析とデバッグツールを提供する。こういった理由で、GHCは本書を通して使われるHaskellの実装とする。
GHCは3つの主な要素からなる:
ghc 速いネイティブコードを生成する最適化コンパイラ
ghci インタラクティブインタプリタとデバッガ
runghc Haskellプログラムをまずコンパイルせずに、スクリプトとして実行するプログラム

<h2>How we refer to the components of GHC</h2>
我々がGHCシステムを全体として議論するときは、GHCとして参照する。もし個別のコマンドについて話すときは、ghc、ghci、runghcと名前で言及する。
我々は最低でもGHC バージョン 6.8.2を使っていると仮定する、それは2007年にリリースされたものだ。例の多くは変更なしに他のバージョンでも動くだろう。しかし、我々はそのプラットフォーム上で最新のバージョンを使うことを勧める。もしWindowsかMacOSXを使っているならビルド済みインストーラを用いて簡単に手早く始められる。これらのプラットフォーム向けのGHCを手に入れるにはGHCダウンロードページに行き、バイナリパッケージとインストーラを探すことだ。
多くのLinuxディストリビューションとBSD、その他各種UnixはGHCの特製バイナリパッケージを使えるようにしてある。それぞれの環境に特有にビルドしてあるので、それらパッケージはGHCダウンロードページにある一般用バイナリパッケージよりもインストールしやすく、使いやすい。GHCのdistribution packagesのページで特製のGHCビルドのあるディストリビューションのリストを見つけられる。
さらに詳細なGHCのインストール情報についてはAppendix Aにやりかたを記した。

<h2>Getting Started with ghci, the Interpreter</h2>
ghcのインタラクティブなインタプリタはghciと名づけられている。それにより我々はHaskellの表現を入力、評価し、モジュールを探索し、コードをデバッグする。PythonやRubyになれているのなら、ghciはインタラクティブなPythonやRubyのインタプリタであるpythonやirbのようなものだ。

<h2>The ghci command has a narrow focus</h2>
我々は形式的にHaskellソースファイルからいくつかのコードをコピーし、ghciにペーストはできない。このことはコードの断片をデバッグするのに意味ある効果をもたないが、もしあなたが、そう、インタラクティブなPythonインタプリタを使っているなら、最初は驚くだろう。

Unix的システムではシェルウィンドウでghciをコマンドとして実行する。Windowsではスタートメニューから可能。たとえばWindows XPでGHCインストーラを使ってプログラムをインストールするなら、All programs、GHCと行くべきだ;リストにghciがあるだろう(Windows でスクリーンショットが見られる)。
ghciを動かすとき、スタートアップバナーを表示し、次いで Prelude>  プロンプトを表示する。ここにLInux boxでのバージョン6.8.3を見ることができる。

<pre>
$ ghci
GHCi, version  6.8.3: http://www.haskell.org/ghc :? for elp
Loading package base ... linking ... done.
Prelude>
</pre>

プロンプトのPreludeという単語は、有用な関数の標準ライブラリであるPreludeがロードされ、使用可能であることを示している。他のモジュールやソースファイルをロードしたときには、プロンプトに同様に表示される。

<H2>Getting help</h2>
ghciプロンプトで :? と入力すると、長いヘルプメッセージが表示される。
Preludeモジュールは時に「標準prelude」として参照される。というのはその内容がHaskel98標準で定義されているからである。普通は単に「prelude」と略される。

<h2>About the ghci prompt</h2>
ghciによって表示されるプロンプトはどのモジュールをロードしたかにより頻繁に変化する。しばしばインプット画面の一行の余地がほとんどなくなるほど長くなることもある。
a簡潔と一貫性のため、本書ではghciのデフォルトのプロンプトをghci>に置き換える。
もし自分でこの様にしたければ、ghciの :set プロンプト指令を、次の様につかえばよい:

<pre>
Prelude> :set prompt "ghci> "
ghci>
<pre>

Preludeは常にさりげなく使える様になっている;我々はそれに定義されている型や値、関数を使うのに何もしなくても良い。その他のモジュールからの定義を使うには、それを:moduleコマンドを用いてghciにロードしなければならない:

<pre>
ghci> :module + Data.Ratio
</pre>

これでData.Ratioモジュールの関数を使えるようになる、それにより有理数(分数)で仕事ができる。

<h2>Basic Inreraction: Using ghci as a Calculator</h2>

コードの断片をテストする便利なインターフェイスを提供するのに加えて、ghciはすぐに使える卓上計算機としての機能をもつ。我々は簡単にghciで計算命令を表現できるうえに、おまけにHaskellに親しむにつれてより複雑な命令を付け加えることができるようになる。こういった単純な方法でインタプリタを使うことさえもHaskellの働きかたを楽に扱えるようになる助けとなる。

<h2>Simple Arithmetic</h2>

我々は、ghciがどうするかを見るために、すぐに表現を入力し始められる。基本的な計算はCやPythonなどの言語と似たように働くーー表現を「挿入」形式で記述する、そこでは演算子はオペランドの間に現れる。

<pre>
ghci> 2 + 2
4
ghci> 31337 * 101
3165037
ghci> 7.0 / 2.0
3.5
</pre>

挿入形式の表現は単純に便利である; また前置型で表記することもでき、その場合は演算子は引数の前にくる。そのためには演算子をカッコでかこまなければならない

<pre>
ghci> 2 + 2
4
ghci> (+) 2 2
4
</pre>

このような表現が示すように、Haskellは整数と浮動小数点数の概念を持つ。整数は任意の大きさを持つ。ここでは(^)は整数のべき乗を提供している。

<pre>
ghci> 313 ^ 15
27112218957718876716220410905036741257
</pre>

<h2>An Arithmetic Quirk: Writing Native Numbers</h2>
Haskellは数字の書き方に特殊性がある:負数はカッコでくくる必要が多くの場合あるのだ。このことは単純な表現以上に進むやいなや影響が出てくる。
ある負数を書いてみよう。

<pre>
ghci> -3
-3
</pre>

先のコードの「−」は単一の演算子である。いいかえれば、「-3」という一つの数を書いたわけではない;「3」という数字を書いて、それに「-」という演算子を適用したのだ。「-」演算子はHaskellの唯一の単一演算子であり、挿入演算子と混ぜられない。

<pre>
ghci> 2 + -3
<interactive>:1:0:
    Precedence parsing error
        cannot mix `(+)' [infixl 6] and prefix `-' [infixl 6] in the same infix expression
</pre>

もし挿入演算子の近くで単一のマイナスを使いたければ、その表現をカッコで包まなければいけない。

<pre>
ghci> 2 + (-3)
-1
ghci> 3 + (-(13 * 37))
-478
</pre>

これで解釈の曖昧さを避けられる。Haskellで関数を適用するとき、関数の名前を書いてその後に引数を書く−例えば「f 3」の様に。もし負数をカッコに入れる必要が無ければ、「f -3」を読むときに二つのまったく異なった読み方があることになる:「関数fを数-3に適用する」または「変数fから数3を引く」のいずれもありうる。
ほとんどの場合、表現の中の空白(スペースやタブのような「ブランク」文字)は無視でき、Haskellは我々が意図するように解釈する。しかし常にではない。次は動作する表現だが:

<pre>
ghci> 2*3
6
</pre>

そして次は以前の問題のある負数表現例と似ているが、異なったエラーメッセージとなる:

<pre>
ghci> 2*-3
<interactive>:1:1: Not in scope: `*-'
</pre>

ここではHaskellの実装は「*-」を一つの演算子と読んでいる。Haskellは我々に新しい演算子(後に触れる話題)の定義を許容するが、しかし我々は「*-」を定義していない。もう一度、いくつかのカッコは我々とghciに同じようにその表現を見せる:

<pre>
ghci> 2*(-3)
-6
</pre>

他の言語と比べて、この負数の独特な取扱いに悩まされるが、これは理由のある取引である。Haskellはいつでも新しい演算子を許容する。これは難解な言語機能というほどでもない:この先の章では相当量のユーザ定義演算子を見るだろう。言語設計者はこの表現力と引き換えに負数のやや面倒な文法を受け入れようと決めた。

<h2>Boolean Logic, Operators, and Value Comparisons</h2>
Haskellでのブール論理式の値は「True」と「False」である。名前が大文字から始まることは重要である。この言語はCに影響されて、ブール値を扱うのにCに影響された演算子を用いる:(&&)は論理的な「and」(論理積)、(||)は論理的な「or」(論理和):

<pre>
ghci> True && False
False
ghci> False || True
True
</pre>

数字0をFalseの別名として扱うプログラム言語がある一方、Haskellはそうせず、非0の値をTrueと考えることもない:

<pre>
ghci> True && 1

<interactive>:1:8:
    No instance for (Num Bool)
      arising from the literal `1' at <interactive>:1:8
    Possible fix: add an instance declaration for (Num Bool)
    In the second argument of `(&&)', namely `1'
    In the expression: True && 1
    In an definition of `it': it = True && 1
</pre>

もう一度、我々は重要そうなエラーメッセージに遭遇している。要するに、boolean型、Bool、は数字型、Numの仲間ではない。エラーメッセージはやや長いが、これはghciが問題の場所を示し、修正できる可能性のある点を示しているからだ。
もっと詳細にエラーメッセージを分析しよう:

No instance for (Num Bool)

ghciが数値1をBool型として扱おうとしていると言っているが、不能

arising from the literal '1'

数値1を使ったために問題が起きたと表示している

In the definition of 'it'

ghciのショートカットを参照している。これは数ページ先に再度触れる。

<h2>Remain fearless in the face of error messages</h2>

ここで重要な点、すなわち本書の最初の章全体を繰り返す点に至った。もしもあなたが未だ理解できない問題やエラーメッセージに陥っても、「パニクるな」。最初にすべきことは問題点において、進歩できるほどの十分な理解をすることだ。経験を積めば、最初は難解に見えたエラーメッセージの箇所を理解し易くなっているのに気づくだろう。
多くのエラーメッセージには目的がある:それは実際に、プログラムを動かす前にさえ、いくらかのデバッグの前衛となることで正しいコードを書く助けになる。もしより放任的な言語で仕事をした背景があるのなら、なにかしらショックかもしれない。一緒に頑張ろう。
Haskellの比較演算子の多くはCやその影響を受けた言語のものと似ている。

<pre>
ghci> 1 == 1
True
ghci> 2 < 3
True
ghci> 4 >= 3.99
True
</pre>

Cのものと一つ違う演算子は「等しくない」だ。Cでは != と書くが、Haskellでは (/=) と書く、これは数学での≠記号に似ている。

<pre>
ghci> 2 /= 3
True
</pre>

同じくC風の言語はよく ! を論理的否定に用いるが、Haskellは not 関数を用いる:

<pre>
ghci> not True
False
</pre>

<h2>Operator Precedence and Associativity</h2>

数式やその他の挿入演算子を用いるプログラム言語の様に、Haskellは演算子優先度の概念を持っている。我々は表現の部分を明示的にグループ化するためにカッコを用いるが、優先度によりいくつかのカッコを省くことができる。例えば乗算演算子は加算演算子よりも高い優先度を持ち、そのためHaskellは次の2つの表現を等しく扱う:

<pre>
ghci> 1 + (4 * 4)
17
ghci> 1 + 4 * 4
17
</pre>

Haskellは演算子に、1が最低で9が最高の、優先度数値を割り当てている。より高い優先度の演算子はより低いのよりも前に適用される。個々の演算子の優先順位をしらべるのにghciを使うことができる、ghciの:infoコマンドを使うのだ:

ghci> info (+)
class (Eq a, Show a) => Num a where
  (+) :: a -> a -> a
  ...
      	-- Defined in GHC.Num
infixl 6 +
ghci> :info (*)
class (Eq a, Show a) => Num a where
  ...
  (*) :: a -> a -> a
  ...
      	-- Defined in GHC.Num
infixl 7 *
</pre>

我々が求める情報は「infixl 6 +」の行にあり、それは(+)演算子が優先度6であると示している。(その他の出力については後の章で説明する) infixl 7 * は(*)演算子が優先度7であると示す。(*)は(+)よりも優先度が高いため、なぜ 1 + 4 * 4 が 1 + (4 * 4) と同じように評価され、(1 + 4) * 4 とはならないのかが理解される。
Haskellはまた演算子の結合則を定義する。これにより複数の演算子を含むある表現が左から評価されるか、右からかを定める。(+)と(*)演算子は左結合である、これは先のghciの出力でinfixlと表されている。右結合の演算子はinfixrと表される。

<pre>
ghci> :info (^)
(^) :: (Num a, Integral b) => a -> b -> a 	-- Defined in GHC.Real
infixr 8 ^
</pre>

優先度と結合則の組み合わせは通常「fixityルール」として参照される。

＜h2>Undefined Values, and Introducing Variables</h2>

Haskellの、先に触れた標準ライブラリであるPreludeは少なくとも一つのよく知られた数学的定数を提供する:

<pre>
ghci> pi
3.141592653589793
</pre>

しかしその数学的定数の網羅範囲は、簡単に分かるが、広くはない。オイラー数、eを見てみよう:

<pre>
ghci> e

<interactive>:1:0: Not in scope: `e'
</pre>

しかたない。自分で定義しなければいけない。

<h2>Don't worry about the error message</h2>
もし「not in scope」エラーメッセージに少しめげても、心配は無い。それが意味するのはeという名前で定義された変数は無いということだけだ。

ghciのlet構成を使って、自分で一時的なeの定義をすることができる:

<pre>
ghci> let e = exp 1
</pre>

これは指数関数、expの利用であり、Haskellでの関数の最初の利用例である。Pythonのような言語は関数の引数の回りにはカッコを要するが、Haskellはそうではない。
eを定義して、いまや我々は数学的表現中でそれを使える様になった。先に導入した(^)べき乗演算子はある数を整数乗にべき乗するものである。浮動点数を指数として使うためには、(**)べき乗演算子を用いる:

<pre>
ghci> (e ** pi) - pi
19.99909997918947
</pre>

<h3>This syntax is ghci-specific</h3>
ghciの受け入れるlet文法は通常のHaskellプログラムの「トップレベル」で用いるものとは異なっている。通常の文法は「introducing Local Variables」で見る

<h2>Dealing with Precedence and Associativity Rules</h2>
Haskellがカッコを省くことを許しても、少なくともいくつかのカッコを残しておく方が良いときがある。それがあることで将来それを読むもの(我々自身を含む)が意図を理解する助けになる。
更に重要なことに、演算子の優先度に完全に依存した複雑な表現はまぎれもなくバグの源である。コンパイラと人間は、短い、カッコの無い表現がしようとしていることさえも違った理解をしてしまうことがよくある。
全ての優先度と結合則を覚える必要は無い:わからなければカッコを付け加える方が簡単だ。

<h2>Command-Line Editing in ghci</h2>


