本書の前章の通り、我々は時に制限つきの、単純化した形でアイデアを紹介することを覚えておいてほしい。Haskellは深みのある言語であり、与えられた話題の全ての局面を一度に提示することは恐らく圧倒的と証明する。我々はHaskellで堅固な基礎を築き、この最初の説明を発展していくだろう。

<h2>Your Haskell Environment</h2>
Haskellは多くの実装のある言語であり、そのうち二つが広く使われている。Hugsはインタプリタであり、第一に教育に使われている。実際的なアプリケーションにはGlasgow Haskell Compiler(GHC)がより一般的である。Hugsに比べてGHCは実務に適している:それはネイティブコードにコンパイルし、並列実行をサポートし、有用なパフォーマンス分析とデバッグツールを提供する。こういった理由で、GHCは本書を通して使われるHaskellの実装とする。
GHCは3つの主な要素からなる:
ghc 速いネイティブコードを生成する最適化コンパイラ
ghci インタラクティブインタプリタとデバッガ
runghc Haskellプログラムをまずコンパイルせずに、スクリプトとして実行するプログラム

<h2>How we refer to the components of GHC</h2>
我々がGHCシステムを全体として議論するときは、GHCとして参照する。もし個別のコマンドについて話すときは、ghc、ghci、runghcと名前で言及する。
我々は最低でもGHC バージョン 6.8.2を使っていると仮定する、それは2007年にリリースされたものだ。例の多くは変更なしに他のバージョンでも動くだろう。しかし、我々はそのプラットフォーム上で最新のバージョンを使うことを勧める。もしWindowsかMacOSXを使っているならビルド済みインストーラを用いて簡単に手早く始められる。これらのプラットフォーム向けのGHCを手に入れるにはGHCダウンロードページに行き、バイナリパッケージとインストーラを探すことだ。
多くのLinuxディストリビューションとBSD、その他各種UnixはGHCの特製バイナリパッケージを使えるようにしてある。それぞれの環境に特有にビルドしてあるので、それらパッケージはGHCダウンロードページにある一般用バイナリパッケージよりもインストールしやすく、使いやすい。GHCのdistribution packagesのページで特製のGHCビルドのあるディストリビューションのリストを見つけられる。
さらに詳細なGHCのインストール情報についてはAppendix Aにやりかたを記した。

<h2>Getting Started with ghci, the Interpreter</h2>
ghcのインタラクティブなインタプリタはghciと名づけられている。それにより我々はHaskellの表現を入力、評価し、モジュールを探索し、コードをデバッグする。PythonやRubyになれているのなら、ghciはインタラクティブなPythonやRubyのインタプリタであるpythonやirbのようなものだ。

<h2>The ghci command has a narrow focus</h2>
我々は形式的にHaskellソースファイルからいくつかのコードをコピーし、ghciにペーストはできない。このことはコードの断片をデバッグするのに意味ある効果をもたないが、もしあなたが、そう、インタラクティブなPythonインタプリタを使っているなら、最初は驚くだろう。

Unix的システムではシェルウィンドウでghciをコマンドとして実行する。Windowsではスタートメニューから可能。たとえばWindows XPでGHCインストーラを使ってプログラムをインストールするなら、All programs、GHCと行くべきだ;リストにghciがあるだろう(Windows でスクリーンショットが見られる)。
ghciを動かすとき、スタートアップバナーを表示し、次いで Prelude>  プロンプトを表示する。ここにLInux boxでのバージョン6.8.3を見ることができる。

<pre>
$ ghci
GHCi, version  6.8.3: http://www.haskell.org/ghc :? for elp
Loading package base ... linking ... done.
Prelude>
</pre>

プロンプトのPreludeという単語は、有用な関数の標準ライブラリであるPreludeがロードされ、使用可能であることを示している。他のモジュールやソースファイルをロードしたときには、プロンプトに同様に表示される。

<H2>Getting help</h2>
ghciプロンプトで :? と入力すると、長いヘルプメッセージが表示される。
Preludeモジュールは時に「標準prelude」として参照される。というのはその内容がHaskel98標準で定義されているからである。普通は単に「prelude」と略される。

<h2>About the ghci prompt</h2>
ghciによって表示されるプロンプトはどのモジュールをロードしたかにより頻繁に変化する。しばしばインプット画面の一行の余地がほとんどなくなるほど長くなることもある。
a簡潔と一貫性のため、本書ではghciのデフォルトのプロンプトをghci>に置き換える。
もし自分でこの様にしたければ、ghciの :set プロンプト指令を、次の様につかえばよい:

<pre>
Prelude> :set prompt "ghci> "
ghci>
<pre>

Preludeは常にさりげなく使える様になっている;我々はそれに定義されている型や値、関数を使うのに何もしなくても良い。その他のモジュールからの定義を使うには、それを:moduleコマンドを用いてghciにロードしなければならない:

<pre>
ghci> :module + Data.Ratio
</pre>

これでData.Ratioモジュールの関数を使えるようになる、それにより有理数(分数)で仕事ができる。

<h2>Basic Inreraction: Using ghci as a Calculator</h2>

コードの断片をテストする便利なインターフェイスを提供するのに加えて、ghciはすぐに使える卓上計算機としての機能をもつ。我々は簡単にghciで計算命令を表現できるうえに、おまけにHaskellに親しむにつれてより複雑な命令を付け加えることができるようになる。こういった単純な方法でインタプリタを使うことさえもHaskellの働きかたを楽に扱えるようになる助けとなる。

<h2>Simple Arithmetic</h2>

我々は、ghciがどうするかを見るために、すぐに表現を入力し始められる。基本的な計算はCやPythonなどの言語と似たように働くーー表現を「挿入」形式で記述する、そこでは演算子はオペランドの間に現れる。

<pre>
ghci> 2 + 2
4
ghci> 31337 * 101
3165037
ghci> 7.0 / 2.0
3.5
</pre>

挿入形式の表現は単純に便利である; また前置型で表記することもでき、その場合は演算子は引数の前にくる。そのためには演算子をカッコでかこまなければならない

<pre>
ghci> 2 + 2
4
ghci> (+) 2 2
4
</pre>

このような表現が示すように、Haskellは整数と浮動小数点数の概念を持つ。整数は任意の大きさを持つ。ここでは(^)は整数のべき乗を提供している。

<pre>
ghci> 313 ^ 15
27112218957718876716220410905036741257
</pre>

<h2>An Arithmetic Quirk: Writing Native Numbers</h2>
Haskellは数字の書き方に特殊性がある:負数はカッコでくくる必要が多くの場合あるのだ。このことは単純な表現以上に進むやいなや影響が出てくる。
ある負数を書いてみよう。

<pre>
ghci> -3
-3
</pre>

先のコードの「−」は単一の演算子である。いいかえれば、「-3」という一つの数を書いたわけではない;「3」という数字を書いて、それに「-」という演算子を適用したのだ。「-」演算子はHaskellの唯一の単一演算子であり、挿入演算子と混ぜられない。

<pre>
ghci> 2 + -3
<interactive>:1:0:
    Precedence parsing error
        cannot mix `(+)' [infixl 6] and prefix `-' [infixl 6] in the same infix expression
</pre>

もし挿入演算子の近くで単一のマイナスを使いたければ、その表現をカッコで包まなければいけない。

<pre>
ghci> 2 + (-3)
-1
ghci> 3 + (-(13 * 37))
-478
</pre>

これで解釈の曖昧さを避けられる。Haskellで関数を適用するとき、関数の名前を書いてその後に引数を書く−例えば「f 3」の様に。もし負数をカッコに入れる必要が無ければ、「f -3」を読むときに二つのまったく異なった読み方があることになる:「関数fを数-3に適用する」または「変数fから数3を引く」のいずれもありうる。
ほとんどの場合、表現の中の空白(スペースやタブのような「ブランク」文字)は無視でき、Haskellは我々が意図するように解釈する。しかし常にではない。次は動作する表現だが:

<pre>
ghci> 2*3
6
</pre>

そして次は以前の問題のある負数表現例と似ているが、異なったエラーメッセージとなる:

<pre>
ghci> 2*-3
<interactive>:1:1: Not in scope: `*-'
</pre>

ここではHaskellの実装は「*-」を一つの演算子と読んでいる。Haskellは我々に新しい演算子(後に触れる話題)の定義を許容するが、しかし我々は「*-」を定義していない。もう一度、いくつかのカッコは我々とghciに同じようにその表現を見せる:

<pre>
ghci> 2*(-3)
-6
</pre>

他の言語と比べて、この負数の独特な取扱いに悩まされるが、これは理由のある取引である。Haskellはいつでも新しい演算子を許容する。これは難解な言語機能というほどでもない:この先の章では相当量のユーザ定義演算子を見るだろう。言語設計者はこの表現力と引き換えに負数のやや面倒な文法を受け入れようと決めた。

<h2>Boolean Logic, Operators, and Value Comparisons</h2>

