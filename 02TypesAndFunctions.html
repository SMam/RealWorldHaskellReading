Capter 2. Types and Functions

なぜ型に気を遣うのか

Haskellでの全ての表現と関数は型を持つ。例えば True という値は Bool という型を持ち、一方 "foo"という値は String という型を持っている。ある値の型は、同じ型の他の値と同じくある属性を持つことを示している。例えば数は足すことができ、リストは結合できる; これらはその型の属性である。ある表現は「xの型を持つ」、あるいは「型xである」と言おう。

更にHaskellの型システムについての議論を深める前に、なぜまったく型に注意しなければならないのか話そう: 何のために? 最も低いレベルでは、コンピュータはバイト列に関係するが、他の追加的な構造にはほとんど関係しない。型システムがもたらすのは抽象化である。型は単なるバイト列に意味を与える: 「このバイト列はテキストだ」、「あのバイト列は飛行機の予約だ」などなど。通常は型システムはこれ以上に、誤って型が混じることを予防するようになっている: 例えば型システムはホテルの予約をレンタカーの領収書として取り扱えないようにしてくれる。

抽象化を導入する利点は低いレベルの細かな点を忘れるあるいは無視することができることだ。もしプログラム中のある値が string と知っていれば、どのように string が実装されているかの詳細を知る必要はない: 単にこれまで使ってきたその他の string と同じように振る舞うだろうとみなせるのだ。

多くの型システムで面白いのは、それらがまったく同等なわけではないということだ。実際、異なる型システムはしばしば同じ種類の問題とは関係しない。あるプログラム言語の型システムは、その言語での我々の考え方、コードの書き方に深く影響を与える。

Haskellの型システムは非常に抽象的なレベルで考えることを許容する: そのため我々は簡潔に強力なプログラムを書くことができる。

Haskell's type system

Haskellの型には3つの興味深い局面がある: それは強力で、静的で、そして自動的に推論されうる。それぞれの概念についてもっと詳しく語ろう。可能な場合には、Haskellの型システムとその他の言語の関連した考えのコンセプトの類似点を示す。またこれらの属性のそれぞれの強さと弱さについてもそれぞれ触れる。

Strong types

Haskellには強い型システムがあると言う場合、型システムがプログラムにある種のエラーが含まれていないことを保証するという意味である。これらのエラーは意味をなさない表現、例えばintegerを関数として用いるような、を書こうとして起きるものだ。例えば、ある関数が整数を扱うことを期待していて、それに文字列を渡したときには、Haskellコンパイラはそれを拒絶する。

ある言語の型規約に従った表現を「well typed」と呼ぶ。これに従わない表現を「ill typed」と呼び、これは「型エラー」を引き起こす。

また別の、Haskellの強い型付けの一面として、ある種類の型を別の型に自動的に強制する事がない。(強制はまたキャストあるいは変換として知られる) 例えばCコンパイラは、ある関数がfloat型のパラメータを期待している時には自動的に、静かにint型を我々のためにfloat型に強制する。しかしHaskellコンパイラは同様の状況ではコンパイルエラーを発生する。変換関数を利用して明示的に強制する必要がある。

強い型付けはある種のコードを書くときに時により困難となる。例えばC言語で低レベルのコードを書く古典的な方法はバイトの配列を与えられて、それらが実際の複雑なデータ構造であるとして扱うためにキャストするというものだ。これは非常に効率的だが、それはそのバイトをコピーする必要がないからである。Haskellの型システムはこの種の強制を許可しない。同様のデータ構造を見るためには、いくらかコピーを行う必要があり、実行時に少しの対価となる。

強い型付けの大きな利点は問題を起こす前にコード内のバグを捉えることができることだ。例えば強い型付け言語では、整数が求められるところでうっかり文字列を使ってしまうことはできない。

より弱い、より強い型付け
多くの言語コミュニティーでは独自に「強い型付け」を定義していることを意識することは有用である。にもかかわらず、簡単に、型システムの強さの概念について広義に語ろう。
学術的な計算機科学では、「強い」「弱い」の意味は狭義の技術的な意味を持つ:強さはいかに型システムが許容的かに関係する。より弱い型システムは、より強いそれに比べて多くの表現を正当として扱う。
例えばPerlでは、"foo"+2 という表現は数2として評価されるが、"13foo"+2 は数15と評価される。Haskellはどちらの表現も不当として拒絶する、なぜなら(+)演算子はその引数が両方とも数であることを必要とするからである。Perlの型システムはHaskellのものよりも許容的であるので、それはこの狭義の技術的実装においてより弱いといえる。
型システム周りのもめごとはもともとの英語に原因があり、「弱い」「強い」という単語に価値の概念をくっつけてしまう:我々はよく強いことは弱いことよりも良いと考える。多くのプログラマは学術的専門用語よりも英語で話し、また極めてしばしば学問は、好みに合わない型システムには何にでも本当に煉瓦を投げつけるのだ。結果はしばしばお馴染みのインターネットの暇つぶし、フレーム合戦となる。

Static types

静的片付けシステムを持つということは、コードが実行される前にコンパイラがコンパイル時に全ての値と表現の型を知っていることを意味している。Haskellコンパイラあるいはインタプリタは型が合わない表現を使おうとすると、実行前にエラーメッセージを出してコードを拒絶する。

<pre>
ghci> True && "false"

<interactive>:1:8:
    Couldn't match expected type `Bool' against inferred type `[Char]'
    In the second argument of `(&&)', namely `"false"'
    In the expression: True && "false"
    In the definition of `it': it = True && "false"
</pre>

このエラーメッセージは前に見たようなものだ。コンパイラは表現"false"の型が[Char]であると推論した。(&&)演算子はそれぞれの引数が型Bool であることを要求し、左の引数は確かにその型である。"false"の実際の型は要求された型と異なるため、コンパイラはこの表現を「ill typed」として拒絶した。
静的型付けは有用な種類のコードを時に書きづらくしうる。Pythonのような言語では、ダックタイピング」が一般的であり、その場合は他のものと十分同じように振る舞うオブジェクトはその代わりとして使えるのである。幸運にもHaskellのtypeclassesシステム、これは第6章で触れるが、これにより動的型付けの利点のほぼ全てが、安全で便利な形で提供される。Haskellは真に動的な型を用いたプログラミングを、それを心から受け止めるような言語ほど易しくはないが、いくらかはサポートする。
Haskellの強い、静的な型付けの組み合わせは実行時に型エラーがでることを不可能にする。このことは「前もって」少し考えることが必要だという意味だが、一方で悪魔的に見つけがたい多くの単純なエラーをなくするのである。Haskellコミュニティ内では、一旦コードがコンパイルされれば他の言語よりもより確実に動くだろう事は自明である(恐らくより現実的には、Haskellのコードには些細なバグがより少ないということである)
動的型付け言語で書かれたプログラムは、単純な型エラーが起きないことを保証するために巨大なテストスイートを必要とする。これは完全には網羅的ではない:プログラムをよりモジュラーにするようにリファクタリングするようなよくある業務は、テストスイートが明らかにできないような新しい型エラーを引き起こしうる。
Haskellではコンパイラは型エラーをなくしてくれる:コンパイルしたHaskellプログラムは実行時に型エラーに悩まされない。リファクタリングは通常コードをあちこち動かして、それから再コンパイルし、コンパイラが「オールクリア」を出すまで何度か整頓することである。
静的型付けの価値を理解する有用な比喩は、ジグソーパズルにピースをはめていくように見ることである。Haskellでは、あるピースが違った形をしていれば単純にはまらない。動的型付け言語では、全てのピースが1x1の正方形で、必ずはまるため、常に出来上がった絵を確かめて、(テストをして)それが正しいかを調べなければいけない。


